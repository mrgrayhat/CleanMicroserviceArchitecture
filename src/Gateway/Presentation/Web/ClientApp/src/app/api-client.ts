/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.2.0.0 (NJsonSchema v10.1.2.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAppClient {
    setLanguage(culture: string | null | undefined): Observable<FileResponse>;
    getApplicationData(): Observable<ApplicationDataViewModel>;
}

@Injectable({
    providedIn: 'root'
})
export class AppClient implements IAppClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    setLanguage(culture: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/App/SetLanguage?";
        if (culture !== undefined)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetLanguage(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSetLanguage(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getApplicationData(): Observable<ApplicationDataViewModel> {
        let url_ = this.baseUrl + "/api/App/GetApplicationData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApplicationData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApplicationData(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationDataViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationDataViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetApplicationData(response: HttpResponseBase): Observable<ApplicationDataViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationDataViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationDataViewModel>(<any>null);
    }
}

export interface IFileConfigurationClient {
    get(): Observable<FileResponse>;
    post(fileConfiguration: FileConfiguration): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class FileConfigurationClient implements IFileConfigurationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/configuration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    post(fileConfiguration: FileConfiguration): Observable<FileResponse> {
        let url_ = this.baseUrl + "/configuration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(fileConfiguration);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IOutputCacheClient {
    delete(region: string | null): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class OutputCacheClient implements IOutputCacheClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    delete(region: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/outputcache/{region}";
        if (region === undefined || region === null)
            throw new Error("The parameter 'region' must be defined.");
        url_ = url_.replace("{region}", encodeURIComponent("" + region)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export class ApplicationDataViewModel implements IApplicationDataViewModel {
    content?: { [key: string]: string; } | undefined;
    cookieConsent?: any | undefined;
    cultures?: CulturesDisplayViewModel[] | undefined;
    environmentInfo?: EnvironmentInformation | undefined;

    constructor(data?: IApplicationDataViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["content"]) {
                this.content = {} as any;
                for (let key in _data["content"]) {
                    if (_data["content"].hasOwnProperty(key))
                        this.content![key] = _data["content"][key];
                }
            }
            this.cookieConsent = _data["cookieConsent"];
            if (Array.isArray(_data["cultures"])) {
                this.cultures = [] as any;
                for (let item of _data["cultures"])
                    this.cultures!.push(CulturesDisplayViewModel.fromJS(item));
            }
            this.environmentInfo = _data["environmentInfo"] ? EnvironmentInformation.fromJS(_data["environmentInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationDataViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationDataViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.content) {
            data["content"] = {};
            for (let key in this.content) {
                if (this.content.hasOwnProperty(key))
                    data["content"][key] = this.content[key];
            }
        }
        data["cookieConsent"] = this.cookieConsent;
        if (Array.isArray(this.cultures)) {
            data["cultures"] = [];
            for (let item of this.cultures)
                data["cultures"].push(item.toJSON());
        }
        data["environmentInfo"] = this.environmentInfo ? this.environmentInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IApplicationDataViewModel {
    content?: { [key: string]: string; } | undefined;
    cookieConsent?: any | undefined;
    cultures?: CulturesDisplayViewModel[] | undefined;
    environmentInfo?: EnvironmentInformation | undefined;
}

export class CulturesDisplayViewModel implements ICulturesDisplayViewModel {
    value?: string | undefined;
    text?: string | undefined;
    current?: boolean;

    constructor(data?: ICulturesDisplayViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.text = _data["text"];
            this.current = _data["current"];
        }
    }

    static fromJS(data: any): CulturesDisplayViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CulturesDisplayViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["text"] = this.text;
        data["current"] = this.current;
        return data; 
    }
}

export interface ICulturesDisplayViewModel {
    value?: string | undefined;
    text?: string | undefined;
    current?: boolean;
}

export class EnvironmentInformation implements IEnvironmentInformation {
    os?: string | undefined;
    machineName?: string | undefined;
    frameworkVersion?: string | undefined;
    environmentName?: string | undefined;
    commitHash?: string | undefined;
    branch?: string | undefined;
    tag?: string | undefined;

    constructor(data?: IEnvironmentInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.os = _data["os"];
            this.machineName = _data["machineName"];
            this.frameworkVersion = _data["frameworkVersion"];
            this.environmentName = _data["environmentName"];
            this.commitHash = _data["commitHash"];
            this.branch = _data["branch"];
            this.tag = _data["tag"];
        }
    }

    static fromJS(data: any): EnvironmentInformation {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["os"] = this.os;
        data["machineName"] = this.machineName;
        data["frameworkVersion"] = this.frameworkVersion;
        data["environmentName"] = this.environmentName;
        data["commitHash"] = this.commitHash;
        data["branch"] = this.branch;
        data["tag"] = this.tag;
        return data; 
    }
}

export interface IEnvironmentInformation {
    os?: string | undefined;
    machineName?: string | undefined;
    frameworkVersion?: string | undefined;
    environmentName?: string | undefined;
    commitHash?: string | undefined;
    branch?: string | undefined;
    tag?: string | undefined;
}

export class FileConfiguration implements IFileConfiguration {
    routes?: FileRoute[] | undefined;
    dynamicRoutes?: FileDynamicRoute[] | undefined;
    aggregates?: FileAggregateRoute[] | undefined;
    globalConfiguration?: FileGlobalConfiguration | undefined;

    constructor(data?: IFileConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["routes"])) {
                this.routes = [] as any;
                for (let item of _data["routes"])
                    this.routes!.push(FileRoute.fromJS(item));
            }
            if (Array.isArray(_data["dynamicRoutes"])) {
                this.dynamicRoutes = [] as any;
                for (let item of _data["dynamicRoutes"])
                    this.dynamicRoutes!.push(FileDynamicRoute.fromJS(item));
            }
            if (Array.isArray(_data["aggregates"])) {
                this.aggregates = [] as any;
                for (let item of _data["aggregates"])
                    this.aggregates!.push(FileAggregateRoute.fromJS(item));
            }
            this.globalConfiguration = _data["globalConfiguration"] ? FileGlobalConfiguration.fromJS(_data["globalConfiguration"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FileConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new FileConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.routes)) {
            data["routes"] = [];
            for (let item of this.routes)
                data["routes"].push(item.toJSON());
        }
        if (Array.isArray(this.dynamicRoutes)) {
            data["dynamicRoutes"] = [];
            for (let item of this.dynamicRoutes)
                data["dynamicRoutes"].push(item.toJSON());
        }
        if (Array.isArray(this.aggregates)) {
            data["aggregates"] = [];
            for (let item of this.aggregates)
                data["aggregates"].push(item.toJSON());
        }
        data["globalConfiguration"] = this.globalConfiguration ? this.globalConfiguration.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFileConfiguration {
    routes?: FileRoute[] | undefined;
    dynamicRoutes?: FileDynamicRoute[] | undefined;
    aggregates?: FileAggregateRoute[] | undefined;
    globalConfiguration?: FileGlobalConfiguration | undefined;
}

export class FileRoute implements IFileRoute {
    downstreamPathTemplate?: string | undefined;
    upstreamPathTemplate?: string | undefined;
    upstreamHttpMethod?: string[] | undefined;
    downstreamHttpMethod?: string | undefined;
    addHeadersToRequest?: { [key: string]: string; } | undefined;
    upstreamHeaderTransform?: { [key: string]: string; } | undefined;
    downstreamHeaderTransform?: { [key: string]: string; } | undefined;
    addClaimsToRequest?: { [key: string]: string; } | undefined;
    routeClaimsRequirement?: { [key: string]: string; } | undefined;
    addQueriesToRequest?: { [key: string]: string; } | undefined;
    changeDownstreamPathTemplate?: { [key: string]: string; } | undefined;
    requestIdKey?: string | undefined;
    fileCacheOptions?: FileCacheOptions | undefined;
    routeIsCaseSensitive?: boolean;
    serviceName?: string | undefined;
    serviceNamespace?: string | undefined;
    downstreamScheme?: string | undefined;
    qoSOptions?: FileQoSOptions | undefined;
    loadBalancerOptions?: FileLoadBalancerOptions | undefined;
    rateLimitOptions?: FileRateLimitRule | undefined;
    authenticationOptions?: FileAuthenticationOptions | undefined;
    httpHandlerOptions?: FileHttpHandlerOptions | undefined;
    downstreamHostAndPorts?: FileHostAndPort[] | undefined;
    upstreamHost?: string | undefined;
    key?: string | undefined;
    delegatingHandlers?: string[] | undefined;
    priority?: number;
    timeout?: number;
    dangerousAcceptAnyServerCertificateValidator?: boolean;
    securityOptions?: FileSecurityOptions | undefined;
    downstreamHttpVersion?: string | undefined;

    constructor(data?: IFileRoute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.downstreamPathTemplate = _data["downstreamPathTemplate"];
            this.upstreamPathTemplate = _data["upstreamPathTemplate"];
            if (Array.isArray(_data["upstreamHttpMethod"])) {
                this.upstreamHttpMethod = [] as any;
                for (let item of _data["upstreamHttpMethod"])
                    this.upstreamHttpMethod!.push(item);
            }
            this.downstreamHttpMethod = _data["downstreamHttpMethod"];
            if (_data["addHeadersToRequest"]) {
                this.addHeadersToRequest = {} as any;
                for (let key in _data["addHeadersToRequest"]) {
                    if (_data["addHeadersToRequest"].hasOwnProperty(key))
                        this.addHeadersToRequest![key] = _data["addHeadersToRequest"][key];
                }
            }
            if (_data["upstreamHeaderTransform"]) {
                this.upstreamHeaderTransform = {} as any;
                for (let key in _data["upstreamHeaderTransform"]) {
                    if (_data["upstreamHeaderTransform"].hasOwnProperty(key))
                        this.upstreamHeaderTransform![key] = _data["upstreamHeaderTransform"][key];
                }
            }
            if (_data["downstreamHeaderTransform"]) {
                this.downstreamHeaderTransform = {} as any;
                for (let key in _data["downstreamHeaderTransform"]) {
                    if (_data["downstreamHeaderTransform"].hasOwnProperty(key))
                        this.downstreamHeaderTransform![key] = _data["downstreamHeaderTransform"][key];
                }
            }
            if (_data["addClaimsToRequest"]) {
                this.addClaimsToRequest = {} as any;
                for (let key in _data["addClaimsToRequest"]) {
                    if (_data["addClaimsToRequest"].hasOwnProperty(key))
                        this.addClaimsToRequest![key] = _data["addClaimsToRequest"][key];
                }
            }
            if (_data["routeClaimsRequirement"]) {
                this.routeClaimsRequirement = {} as any;
                for (let key in _data["routeClaimsRequirement"]) {
                    if (_data["routeClaimsRequirement"].hasOwnProperty(key))
                        this.routeClaimsRequirement![key] = _data["routeClaimsRequirement"][key];
                }
            }
            if (_data["addQueriesToRequest"]) {
                this.addQueriesToRequest = {} as any;
                for (let key in _data["addQueriesToRequest"]) {
                    if (_data["addQueriesToRequest"].hasOwnProperty(key))
                        this.addQueriesToRequest![key] = _data["addQueriesToRequest"][key];
                }
            }
            if (_data["changeDownstreamPathTemplate"]) {
                this.changeDownstreamPathTemplate = {} as any;
                for (let key in _data["changeDownstreamPathTemplate"]) {
                    if (_data["changeDownstreamPathTemplate"].hasOwnProperty(key))
                        this.changeDownstreamPathTemplate![key] = _data["changeDownstreamPathTemplate"][key];
                }
            }
            this.requestIdKey = _data["requestIdKey"];
            this.fileCacheOptions = _data["fileCacheOptions"] ? FileCacheOptions.fromJS(_data["fileCacheOptions"]) : <any>undefined;
            this.routeIsCaseSensitive = _data["routeIsCaseSensitive"];
            this.serviceName = _data["serviceName"];
            this.serviceNamespace = _data["serviceNamespace"];
            this.downstreamScheme = _data["downstreamScheme"];
            this.qoSOptions = _data["qoSOptions"] ? FileQoSOptions.fromJS(_data["qoSOptions"]) : <any>undefined;
            this.loadBalancerOptions = _data["loadBalancerOptions"] ? FileLoadBalancerOptions.fromJS(_data["loadBalancerOptions"]) : <any>undefined;
            this.rateLimitOptions = _data["rateLimitOptions"] ? FileRateLimitRule.fromJS(_data["rateLimitOptions"]) : <any>undefined;
            this.authenticationOptions = _data["authenticationOptions"] ? FileAuthenticationOptions.fromJS(_data["authenticationOptions"]) : <any>undefined;
            this.httpHandlerOptions = _data["httpHandlerOptions"] ? FileHttpHandlerOptions.fromJS(_data["httpHandlerOptions"]) : <any>undefined;
            if (Array.isArray(_data["downstreamHostAndPorts"])) {
                this.downstreamHostAndPorts = [] as any;
                for (let item of _data["downstreamHostAndPorts"])
                    this.downstreamHostAndPorts!.push(FileHostAndPort.fromJS(item));
            }
            this.upstreamHost = _data["upstreamHost"];
            this.key = _data["key"];
            if (Array.isArray(_data["delegatingHandlers"])) {
                this.delegatingHandlers = [] as any;
                for (let item of _data["delegatingHandlers"])
                    this.delegatingHandlers!.push(item);
            }
            this.priority = _data["priority"];
            this.timeout = _data["timeout"];
            this.dangerousAcceptAnyServerCertificateValidator = _data["dangerousAcceptAnyServerCertificateValidator"];
            this.securityOptions = _data["securityOptions"] ? FileSecurityOptions.fromJS(_data["securityOptions"]) : <any>undefined;
            this.downstreamHttpVersion = _data["downstreamHttpVersion"];
        }
    }

    static fromJS(data: any): FileRoute {
        data = typeof data === 'object' ? data : {};
        let result = new FileRoute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["downstreamPathTemplate"] = this.downstreamPathTemplate;
        data["upstreamPathTemplate"] = this.upstreamPathTemplate;
        if (Array.isArray(this.upstreamHttpMethod)) {
            data["upstreamHttpMethod"] = [];
            for (let item of this.upstreamHttpMethod)
                data["upstreamHttpMethod"].push(item);
        }
        data["downstreamHttpMethod"] = this.downstreamHttpMethod;
        if (this.addHeadersToRequest) {
            data["addHeadersToRequest"] = {};
            for (let key in this.addHeadersToRequest) {
                if (this.addHeadersToRequest.hasOwnProperty(key))
                    data["addHeadersToRequest"][key] = this.addHeadersToRequest[key];
            }
        }
        if (this.upstreamHeaderTransform) {
            data["upstreamHeaderTransform"] = {};
            for (let key in this.upstreamHeaderTransform) {
                if (this.upstreamHeaderTransform.hasOwnProperty(key))
                    data["upstreamHeaderTransform"][key] = this.upstreamHeaderTransform[key];
            }
        }
        if (this.downstreamHeaderTransform) {
            data["downstreamHeaderTransform"] = {};
            for (let key in this.downstreamHeaderTransform) {
                if (this.downstreamHeaderTransform.hasOwnProperty(key))
                    data["downstreamHeaderTransform"][key] = this.downstreamHeaderTransform[key];
            }
        }
        if (this.addClaimsToRequest) {
            data["addClaimsToRequest"] = {};
            for (let key in this.addClaimsToRequest) {
                if (this.addClaimsToRequest.hasOwnProperty(key))
                    data["addClaimsToRequest"][key] = this.addClaimsToRequest[key];
            }
        }
        if (this.routeClaimsRequirement) {
            data["routeClaimsRequirement"] = {};
            for (let key in this.routeClaimsRequirement) {
                if (this.routeClaimsRequirement.hasOwnProperty(key))
                    data["routeClaimsRequirement"][key] = this.routeClaimsRequirement[key];
            }
        }
        if (this.addQueriesToRequest) {
            data["addQueriesToRequest"] = {};
            for (let key in this.addQueriesToRequest) {
                if (this.addQueriesToRequest.hasOwnProperty(key))
                    data["addQueriesToRequest"][key] = this.addQueriesToRequest[key];
            }
        }
        if (this.changeDownstreamPathTemplate) {
            data["changeDownstreamPathTemplate"] = {};
            for (let key in this.changeDownstreamPathTemplate) {
                if (this.changeDownstreamPathTemplate.hasOwnProperty(key))
                    data["changeDownstreamPathTemplate"][key] = this.changeDownstreamPathTemplate[key];
            }
        }
        data["requestIdKey"] = this.requestIdKey;
        data["fileCacheOptions"] = this.fileCacheOptions ? this.fileCacheOptions.toJSON() : <any>undefined;
        data["routeIsCaseSensitive"] = this.routeIsCaseSensitive;
        data["serviceName"] = this.serviceName;
        data["serviceNamespace"] = this.serviceNamespace;
        data["downstreamScheme"] = this.downstreamScheme;
        data["qoSOptions"] = this.qoSOptions ? this.qoSOptions.toJSON() : <any>undefined;
        data["loadBalancerOptions"] = this.loadBalancerOptions ? this.loadBalancerOptions.toJSON() : <any>undefined;
        data["rateLimitOptions"] = this.rateLimitOptions ? this.rateLimitOptions.toJSON() : <any>undefined;
        data["authenticationOptions"] = this.authenticationOptions ? this.authenticationOptions.toJSON() : <any>undefined;
        data["httpHandlerOptions"] = this.httpHandlerOptions ? this.httpHandlerOptions.toJSON() : <any>undefined;
        if (Array.isArray(this.downstreamHostAndPorts)) {
            data["downstreamHostAndPorts"] = [];
            for (let item of this.downstreamHostAndPorts)
                data["downstreamHostAndPorts"].push(item.toJSON());
        }
        data["upstreamHost"] = this.upstreamHost;
        data["key"] = this.key;
        if (Array.isArray(this.delegatingHandlers)) {
            data["delegatingHandlers"] = [];
            for (let item of this.delegatingHandlers)
                data["delegatingHandlers"].push(item);
        }
        data["priority"] = this.priority;
        data["timeout"] = this.timeout;
        data["dangerousAcceptAnyServerCertificateValidator"] = this.dangerousAcceptAnyServerCertificateValidator;
        data["securityOptions"] = this.securityOptions ? this.securityOptions.toJSON() : <any>undefined;
        data["downstreamHttpVersion"] = this.downstreamHttpVersion;
        return data; 
    }
}

export interface IFileRoute {
    downstreamPathTemplate?: string | undefined;
    upstreamPathTemplate?: string | undefined;
    upstreamHttpMethod?: string[] | undefined;
    downstreamHttpMethod?: string | undefined;
    addHeadersToRequest?: { [key: string]: string; } | undefined;
    upstreamHeaderTransform?: { [key: string]: string; } | undefined;
    downstreamHeaderTransform?: { [key: string]: string; } | undefined;
    addClaimsToRequest?: { [key: string]: string; } | undefined;
    routeClaimsRequirement?: { [key: string]: string; } | undefined;
    addQueriesToRequest?: { [key: string]: string; } | undefined;
    changeDownstreamPathTemplate?: { [key: string]: string; } | undefined;
    requestIdKey?: string | undefined;
    fileCacheOptions?: FileCacheOptions | undefined;
    routeIsCaseSensitive?: boolean;
    serviceName?: string | undefined;
    serviceNamespace?: string | undefined;
    downstreamScheme?: string | undefined;
    qoSOptions?: FileQoSOptions | undefined;
    loadBalancerOptions?: FileLoadBalancerOptions | undefined;
    rateLimitOptions?: FileRateLimitRule | undefined;
    authenticationOptions?: FileAuthenticationOptions | undefined;
    httpHandlerOptions?: FileHttpHandlerOptions | undefined;
    downstreamHostAndPorts?: FileHostAndPort[] | undefined;
    upstreamHost?: string | undefined;
    key?: string | undefined;
    delegatingHandlers?: string[] | undefined;
    priority?: number;
    timeout?: number;
    dangerousAcceptAnyServerCertificateValidator?: boolean;
    securityOptions?: FileSecurityOptions | undefined;
    downstreamHttpVersion?: string | undefined;
}

export class FileCacheOptions implements IFileCacheOptions {
    ttlSeconds?: number;
    region?: string | undefined;

    constructor(data?: IFileCacheOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ttlSeconds = _data["ttlSeconds"];
            this.region = _data["region"];
        }
    }

    static fromJS(data: any): FileCacheOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileCacheOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ttlSeconds"] = this.ttlSeconds;
        data["region"] = this.region;
        return data; 
    }
}

export interface IFileCacheOptions {
    ttlSeconds?: number;
    region?: string | undefined;
}

export class FileQoSOptions implements IFileQoSOptions {
    exceptionsAllowedBeforeBreaking?: number;
    durationOfBreak?: number;
    timeoutValue?: number;

    constructor(data?: IFileQoSOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exceptionsAllowedBeforeBreaking = _data["exceptionsAllowedBeforeBreaking"];
            this.durationOfBreak = _data["durationOfBreak"];
            this.timeoutValue = _data["timeoutValue"];
        }
    }

    static fromJS(data: any): FileQoSOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileQoSOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exceptionsAllowedBeforeBreaking"] = this.exceptionsAllowedBeforeBreaking;
        data["durationOfBreak"] = this.durationOfBreak;
        data["timeoutValue"] = this.timeoutValue;
        return data; 
    }
}

export interface IFileQoSOptions {
    exceptionsAllowedBeforeBreaking?: number;
    durationOfBreak?: number;
    timeoutValue?: number;
}

export class FileLoadBalancerOptions implements IFileLoadBalancerOptions {
    type?: string | undefined;
    key?: string | undefined;
    expiry?: number;

    constructor(data?: IFileLoadBalancerOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.key = _data["key"];
            this.expiry = _data["expiry"];
        }
    }

    static fromJS(data: any): FileLoadBalancerOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileLoadBalancerOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["key"] = this.key;
        data["expiry"] = this.expiry;
        return data; 
    }
}

export interface IFileLoadBalancerOptions {
    type?: string | undefined;
    key?: string | undefined;
    expiry?: number;
}

export class FileRateLimitRule implements IFileRateLimitRule {
    clientWhitelist?: string[] | undefined;
    enableRateLimiting?: boolean;
    period?: string | undefined;
    periodTimespan?: number;
    limit?: number;

    constructor(data?: IFileRateLimitRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["clientWhitelist"])) {
                this.clientWhitelist = [] as any;
                for (let item of _data["clientWhitelist"])
                    this.clientWhitelist!.push(item);
            }
            this.enableRateLimiting = _data["enableRateLimiting"];
            this.period = _data["period"];
            this.periodTimespan = _data["periodTimespan"];
            this.limit = _data["limit"];
        }
    }

    static fromJS(data: any): FileRateLimitRule {
        data = typeof data === 'object' ? data : {};
        let result = new FileRateLimitRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.clientWhitelist)) {
            data["clientWhitelist"] = [];
            for (let item of this.clientWhitelist)
                data["clientWhitelist"].push(item);
        }
        data["enableRateLimiting"] = this.enableRateLimiting;
        data["period"] = this.period;
        data["periodTimespan"] = this.periodTimespan;
        data["limit"] = this.limit;
        return data; 
    }
}

export interface IFileRateLimitRule {
    clientWhitelist?: string[] | undefined;
    enableRateLimiting?: boolean;
    period?: string | undefined;
    periodTimespan?: number;
    limit?: number;
}

export class FileAuthenticationOptions implements IFileAuthenticationOptions {
    authenticationProviderKey?: string | undefined;
    allowedScopes?: string[] | undefined;

    constructor(data?: IFileAuthenticationOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authenticationProviderKey = _data["authenticationProviderKey"];
            if (Array.isArray(_data["allowedScopes"])) {
                this.allowedScopes = [] as any;
                for (let item of _data["allowedScopes"])
                    this.allowedScopes!.push(item);
            }
        }
    }

    static fromJS(data: any): FileAuthenticationOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileAuthenticationOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticationProviderKey"] = this.authenticationProviderKey;
        if (Array.isArray(this.allowedScopes)) {
            data["allowedScopes"] = [];
            for (let item of this.allowedScopes)
                data["allowedScopes"].push(item);
        }
        return data; 
    }
}

export interface IFileAuthenticationOptions {
    authenticationProviderKey?: string | undefined;
    allowedScopes?: string[] | undefined;
}

export class FileHttpHandlerOptions implements IFileHttpHandlerOptions {
    allowAutoRedirect?: boolean;
    useCookieContainer?: boolean;
    useTracing?: boolean;
    useProxy?: boolean;
    maxConnectionsPerServer?: number;

    constructor(data?: IFileHttpHandlerOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowAutoRedirect = _data["allowAutoRedirect"];
            this.useCookieContainer = _data["useCookieContainer"];
            this.useTracing = _data["useTracing"];
            this.useProxy = _data["useProxy"];
            this.maxConnectionsPerServer = _data["maxConnectionsPerServer"];
        }
    }

    static fromJS(data: any): FileHttpHandlerOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileHttpHandlerOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowAutoRedirect"] = this.allowAutoRedirect;
        data["useCookieContainer"] = this.useCookieContainer;
        data["useTracing"] = this.useTracing;
        data["useProxy"] = this.useProxy;
        data["maxConnectionsPerServer"] = this.maxConnectionsPerServer;
        return data; 
    }
}

export interface IFileHttpHandlerOptions {
    allowAutoRedirect?: boolean;
    useCookieContainer?: boolean;
    useTracing?: boolean;
    useProxy?: boolean;
    maxConnectionsPerServer?: number;
}

export class FileHostAndPort implements IFileHostAndPort {
    host?: string | undefined;
    port?: number;

    constructor(data?: IFileHostAndPort) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.host = _data["host"];
            this.port = _data["port"];
        }
    }

    static fromJS(data: any): FileHostAndPort {
        data = typeof data === 'object' ? data : {};
        let result = new FileHostAndPort();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["host"] = this.host;
        data["port"] = this.port;
        return data; 
    }
}

export interface IFileHostAndPort {
    host?: string | undefined;
    port?: number;
}

export class FileSecurityOptions implements IFileSecurityOptions {
    ipAllowedList?: string[] | undefined;
    ipBlockedList?: string[] | undefined;

    constructor(data?: IFileSecurityOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ipAllowedList"])) {
                this.ipAllowedList = [] as any;
                for (let item of _data["ipAllowedList"])
                    this.ipAllowedList!.push(item);
            }
            if (Array.isArray(_data["ipBlockedList"])) {
                this.ipBlockedList = [] as any;
                for (let item of _data["ipBlockedList"])
                    this.ipBlockedList!.push(item);
            }
        }
    }

    static fromJS(data: any): FileSecurityOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileSecurityOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ipAllowedList)) {
            data["ipAllowedList"] = [];
            for (let item of this.ipAllowedList)
                data["ipAllowedList"].push(item);
        }
        if (Array.isArray(this.ipBlockedList)) {
            data["ipBlockedList"] = [];
            for (let item of this.ipBlockedList)
                data["ipBlockedList"].push(item);
        }
        return data; 
    }
}

export interface IFileSecurityOptions {
    ipAllowedList?: string[] | undefined;
    ipBlockedList?: string[] | undefined;
}

export class FileDynamicRoute implements IFileDynamicRoute {
    serviceName?: string | undefined;
    rateLimitRule?: FileRateLimitRule | undefined;
    downstreamHttpVersion?: string | undefined;

    constructor(data?: IFileDynamicRoute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serviceName = _data["serviceName"];
            this.rateLimitRule = _data["rateLimitRule"] ? FileRateLimitRule.fromJS(_data["rateLimitRule"]) : <any>undefined;
            this.downstreamHttpVersion = _data["downstreamHttpVersion"];
        }
    }

    static fromJS(data: any): FileDynamicRoute {
        data = typeof data === 'object' ? data : {};
        let result = new FileDynamicRoute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceName"] = this.serviceName;
        data["rateLimitRule"] = this.rateLimitRule ? this.rateLimitRule.toJSON() : <any>undefined;
        data["downstreamHttpVersion"] = this.downstreamHttpVersion;
        return data; 
    }
}

export interface IFileDynamicRoute {
    serviceName?: string | undefined;
    rateLimitRule?: FileRateLimitRule | undefined;
    downstreamHttpVersion?: string | undefined;
}

export class FileAggregateRoute implements IFileAggregateRoute {
    routeKeys?: string[] | undefined;
    routeKeysConfig?: AggregateRouteConfig[] | undefined;
    upstreamPathTemplate?: string | undefined;
    upstreamHost?: string | undefined;
    routeIsCaseSensitive?: boolean;
    aggregator?: string | undefined;
    upstreamHttpMethod?: string[] | undefined;
    priority?: number;

    constructor(data?: IFileAggregateRoute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["routeKeys"])) {
                this.routeKeys = [] as any;
                for (let item of _data["routeKeys"])
                    this.routeKeys!.push(item);
            }
            if (Array.isArray(_data["routeKeysConfig"])) {
                this.routeKeysConfig = [] as any;
                for (let item of _data["routeKeysConfig"])
                    this.routeKeysConfig!.push(AggregateRouteConfig.fromJS(item));
            }
            this.upstreamPathTemplate = _data["upstreamPathTemplate"];
            this.upstreamHost = _data["upstreamHost"];
            this.routeIsCaseSensitive = _data["routeIsCaseSensitive"];
            this.aggregator = _data["aggregator"];
            if (Array.isArray(_data["upstreamHttpMethod"])) {
                this.upstreamHttpMethod = [] as any;
                for (let item of _data["upstreamHttpMethod"])
                    this.upstreamHttpMethod!.push(item);
            }
            this.priority = _data["priority"];
        }
    }

    static fromJS(data: any): FileAggregateRoute {
        data = typeof data === 'object' ? data : {};
        let result = new FileAggregateRoute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.routeKeys)) {
            data["routeKeys"] = [];
            for (let item of this.routeKeys)
                data["routeKeys"].push(item);
        }
        if (Array.isArray(this.routeKeysConfig)) {
            data["routeKeysConfig"] = [];
            for (let item of this.routeKeysConfig)
                data["routeKeysConfig"].push(item.toJSON());
        }
        data["upstreamPathTemplate"] = this.upstreamPathTemplate;
        data["upstreamHost"] = this.upstreamHost;
        data["routeIsCaseSensitive"] = this.routeIsCaseSensitive;
        data["aggregator"] = this.aggregator;
        if (Array.isArray(this.upstreamHttpMethod)) {
            data["upstreamHttpMethod"] = [];
            for (let item of this.upstreamHttpMethod)
                data["upstreamHttpMethod"].push(item);
        }
        data["priority"] = this.priority;
        return data; 
    }
}

export interface IFileAggregateRoute {
    routeKeys?: string[] | undefined;
    routeKeysConfig?: AggregateRouteConfig[] | undefined;
    upstreamPathTemplate?: string | undefined;
    upstreamHost?: string | undefined;
    routeIsCaseSensitive?: boolean;
    aggregator?: string | undefined;
    upstreamHttpMethod?: string[] | undefined;
    priority?: number;
}

export class AggregateRouteConfig implements IAggregateRouteConfig {
    routeKey?: string | undefined;
    parameter?: string | undefined;
    jsonPath?: string | undefined;

    constructor(data?: IAggregateRouteConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.routeKey = _data["routeKey"];
            this.parameter = _data["parameter"];
            this.jsonPath = _data["jsonPath"];
        }
    }

    static fromJS(data: any): AggregateRouteConfig {
        data = typeof data === 'object' ? data : {};
        let result = new AggregateRouteConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["routeKey"] = this.routeKey;
        data["parameter"] = this.parameter;
        data["jsonPath"] = this.jsonPath;
        return data; 
    }
}

export interface IAggregateRouteConfig {
    routeKey?: string | undefined;
    parameter?: string | undefined;
    jsonPath?: string | undefined;
}

export class FileGlobalConfiguration implements IFileGlobalConfiguration {
    requestIdKey?: string | undefined;
    serviceDiscoveryProvider?: FileServiceDiscoveryProvider | undefined;
    rateLimitOptions?: FileRateLimitOptions | undefined;
    qoSOptions?: FileQoSOptions | undefined;
    baseUrl?: string | undefined;
    loadBalancerOptions?: FileLoadBalancerOptions | undefined;
    downstreamScheme?: string | undefined;
    httpHandlerOptions?: FileHttpHandlerOptions | undefined;
    downstreamHttpVersion?: string | undefined;

    constructor(data?: IFileGlobalConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestIdKey = _data["requestIdKey"];
            this.serviceDiscoveryProvider = _data["serviceDiscoveryProvider"] ? FileServiceDiscoveryProvider.fromJS(_data["serviceDiscoveryProvider"]) : <any>undefined;
            this.rateLimitOptions = _data["rateLimitOptions"] ? FileRateLimitOptions.fromJS(_data["rateLimitOptions"]) : <any>undefined;
            this.qoSOptions = _data["qoSOptions"] ? FileQoSOptions.fromJS(_data["qoSOptions"]) : <any>undefined;
            this.baseUrl = _data["baseUrl"];
            this.loadBalancerOptions = _data["loadBalancerOptions"] ? FileLoadBalancerOptions.fromJS(_data["loadBalancerOptions"]) : <any>undefined;
            this.downstreamScheme = _data["downstreamScheme"];
            this.httpHandlerOptions = _data["httpHandlerOptions"] ? FileHttpHandlerOptions.fromJS(_data["httpHandlerOptions"]) : <any>undefined;
            this.downstreamHttpVersion = _data["downstreamHttpVersion"];
        }
    }

    static fromJS(data: any): FileGlobalConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new FileGlobalConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestIdKey"] = this.requestIdKey;
        data["serviceDiscoveryProvider"] = this.serviceDiscoveryProvider ? this.serviceDiscoveryProvider.toJSON() : <any>undefined;
        data["rateLimitOptions"] = this.rateLimitOptions ? this.rateLimitOptions.toJSON() : <any>undefined;
        data["qoSOptions"] = this.qoSOptions ? this.qoSOptions.toJSON() : <any>undefined;
        data["baseUrl"] = this.baseUrl;
        data["loadBalancerOptions"] = this.loadBalancerOptions ? this.loadBalancerOptions.toJSON() : <any>undefined;
        data["downstreamScheme"] = this.downstreamScheme;
        data["httpHandlerOptions"] = this.httpHandlerOptions ? this.httpHandlerOptions.toJSON() : <any>undefined;
        data["downstreamHttpVersion"] = this.downstreamHttpVersion;
        return data; 
    }
}

export interface IFileGlobalConfiguration {
    requestIdKey?: string | undefined;
    serviceDiscoveryProvider?: FileServiceDiscoveryProvider | undefined;
    rateLimitOptions?: FileRateLimitOptions | undefined;
    qoSOptions?: FileQoSOptions | undefined;
    baseUrl?: string | undefined;
    loadBalancerOptions?: FileLoadBalancerOptions | undefined;
    downstreamScheme?: string | undefined;
    httpHandlerOptions?: FileHttpHandlerOptions | undefined;
    downstreamHttpVersion?: string | undefined;
}

export class FileServiceDiscoveryProvider implements IFileServiceDiscoveryProvider {
    scheme?: string | undefined;
    host?: string | undefined;
    port?: number;
    type?: string | undefined;
    token?: string | undefined;
    configurationKey?: string | undefined;
    pollingInterval?: number;
    namespace?: string | undefined;

    constructor(data?: IFileServiceDiscoveryProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scheme = _data["scheme"];
            this.host = _data["host"];
            this.port = _data["port"];
            this.type = _data["type"];
            this.token = _data["token"];
            this.configurationKey = _data["configurationKey"];
            this.pollingInterval = _data["pollingInterval"];
            this.namespace = _data["namespace"];
        }
    }

    static fromJS(data: any): FileServiceDiscoveryProvider {
        data = typeof data === 'object' ? data : {};
        let result = new FileServiceDiscoveryProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheme"] = this.scheme;
        data["host"] = this.host;
        data["port"] = this.port;
        data["type"] = this.type;
        data["token"] = this.token;
        data["configurationKey"] = this.configurationKey;
        data["pollingInterval"] = this.pollingInterval;
        data["namespace"] = this.namespace;
        return data; 
    }
}

export interface IFileServiceDiscoveryProvider {
    scheme?: string | undefined;
    host?: string | undefined;
    port?: number;
    type?: string | undefined;
    token?: string | undefined;
    configurationKey?: string | undefined;
    pollingInterval?: number;
    namespace?: string | undefined;
}

export class FileRateLimitOptions implements IFileRateLimitOptions {
    clientIdHeader?: string | undefined;
    quotaExceededMessage?: string | undefined;
    rateLimitCounterPrefix?: string | undefined;
    disableRateLimitHeaders?: boolean;
    httpStatusCode?: number;

    constructor(data?: IFileRateLimitOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientIdHeader = _data["clientIdHeader"];
            this.quotaExceededMessage = _data["quotaExceededMessage"];
            this.rateLimitCounterPrefix = _data["rateLimitCounterPrefix"];
            this.disableRateLimitHeaders = _data["disableRateLimitHeaders"];
            this.httpStatusCode = _data["httpStatusCode"];
        }
    }

    static fromJS(data: any): FileRateLimitOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileRateLimitOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientIdHeader"] = this.clientIdHeader;
        data["quotaExceededMessage"] = this.quotaExceededMessage;
        data["rateLimitCounterPrefix"] = this.rateLimitCounterPrefix;
        data["disableRateLimitHeaders"] = this.disableRateLimitHeaders;
        data["httpStatusCode"] = this.httpStatusCode;
        return data; 
    }
}

export interface IFileRateLimitOptions {
    clientIdHeader?: string | undefined;
    quotaExceededMessage?: string | undefined;
    rateLimitCounterPrefix?: string | undefined;
    disableRateLimitHeaders?: boolean;
    httpStatusCode?: number;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}